<?php

    class sql_parser_driver_postgresql extends sql_parser_driver {

        public function __construct() {
            foreach ($this->get_all_tables() as $table) {
                $this->get_table_details($table);
            }
        }

        protected function get_all_tables() {
            $sql = core::sql()->prepare("
                SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' ORDER BY table_name ASC
            ");
            $sql->execute();
            $tables = [];
            foreach ($sql->fetchAll() as $table) {
                $tables[] = current($table);
            }
            return array_values($tables);
        }

        protected function get_table_details($table) {
            $info = [
                'name'         => trim(strtolower($table)),
                'fields'       => [],
                'primary_keys' => [],
                'unique_keys'  => [],
                'indexes'      => [],
                'foreign_keys' => [],
            ];

            $sql = core::sql()->prepare("
                SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE table_name = ? ORDER BY ordinal_position ASC
            ");
            $sql->execute([
                $table,
            ]);

            foreach ($sql->fetchAll() as $field) {
                $info['fields'][] = [
                    'name'                 => $field['column_name'],
                    'type'                 => strtolower($field['udt_name']),
                    'size'                 => (int) $field['character_maximum_length'] ?: (int) $field['numeric_precision'],
                    'decimals'             => (int) $field['numeric_scale'] ?: null,
                    'unsigned'             => false,
                    'autoincrement'        => stripos($field['column_default'], 'nextval') !== false,
                    'autogenerated_insert' => $field['column_default'] !== null,
                    'allow_null'           => strtolower($field['is_nullable']) === 'yes',
                    'casting'              => self::field_casting(strtolower($field['udt_name']), (int) $field['character_maximum_length'] ?: (int) $field['numeric_precision']),
                    'casting_extended'     => self::field_casting_extended(strtolower($field['udt_name']), (int) $field['character_maximum_length'] ?: (int) $field['numeric_precision']),
                    'binary'               => self::field_is_binary(strtolower($field['udt_name'])),
                    'bool_true'            => self::boolean_true_value(strtolower($field['udt_name'])),
                ];
            }

            core::debug($info);
        }

        public static function field_casting($type, $length) {
            switch (trim(strtolower($type))) {
                case 'bigint':
                case 'serial':
                case 'bigserial':
                case 'smallint':
                case 'double precision':
                case 'integer':
                case 'interval':
                    return 'int';

                case 'boolean':
                    return 'bool';

                default:
                    return 'string';
            }
        }

        public static function field_casting_extended($type, $length) {
            switch (trim(strtolower($type))) {
                case 'bigint':
                case 'serial':
                case 'bigserial':
                case 'smallint':
                case 'double precision':
                case 'integer':
                case 'interval':
                    return 'int';

                case 'boolean':
                    return 'bool';

                case 'money':
                case 'decimal':
                case 'real':
                case 'numeric':

                case 'bit':
                case 'bit varying':

                case 'tsquery':

                case 'date':
                case 'xml':
                case 'time':
                case 'timez':
                case 'timestamp':
                case 'timestampz':
                case 'text':
                case 'macaddr':
                case 'cidr':
                case 'inet':
                case 'bytea':
                case 'character varying':
                case 'character':
                case 'uuid':

                case 'circle':
                case 'box':
                case 'line':
                case 'lseg':
                case 'path':
                case 'point':
                case 'polygon':
                case 'tsvector':
                case 'txid_snapshot':

                    return 'string';

                default:
                    return 'string';
            }
        }

        public static function field_is_binary($type) {
            return in_array(
                trim(strtolower($type)),
                [
                    'bytea',
                ]
            );
        }

        public function boolean_true_value($details) {
            if (array_key_exists(strtolower($details), self::$enum_values)) {
                return self::$enum_values[strtolower($details)];
            }
        }
    }