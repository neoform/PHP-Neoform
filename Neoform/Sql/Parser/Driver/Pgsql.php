<?php

    namespace Neoform\Sql\Parser\Driver;

    use Neoform\Sql\Parser\Field;
    use Neoform\Sql\Parser\Table;
    use Neoform\Sql\Parser\Driver;
    use Neoform\Sql;

    class Pgsql extends Driver {

        public function __construct() {
            $tables_info = [];
            foreach ($this->getAllTables() as $table) {
                $table_info                        = $this->get_table_details($table);
                $tables_info[$table_info['name']]  = $table_info;
                $this->tables[$table_info['name']] = new Table($table_info);
            }

            // add each table to each of its fields, so a given field can know who it belongs to
            foreach ($this->tables as $table) {
                foreach ($table->getFields() as $field) {
                    $field->_setTable($table);
                }
            }

            // Foreign keys must be done after the table has been parsed (we reference the tables to each other)
            foreach ($tables_info as $table_name => $table_info) {
                $table = $this->tables[$table_name];
                foreach ($table_info['foreignKeys'] as $fk) {
                    if (isset($this->tables[$fk['parentTable']])) {
                        $table->getFields()[$fk['field']]->_setReferencedField($this->tables[$fk['parentTable']]->getFields()[$fk['parentField']]);
                    } else {
                        throw new \Exception("The parent table `{$fk['parentTable']}` was not identified during parsing, is it in this database/schema?");
                    }
                }
            }
        }

        protected function getAllTables() {
            $sql = Sql::instance()->prepare("
                SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' ORDER BY table_name ASC
            ");
            $sql->execute();
            $tables = [];
            foreach ($sql->fetchAll() as $table) {
                $tables[] = current($table);
            }
            return array_values($tables);
        }

        protected function get_table_details($table) {
            $info = [
                'name'         => trim(strtolower($table)),
                'fields'       => [],
                'primaryKeys' => [],
                'uniqueKeys'  => [],
                'indexes'      => [],
                'foreignKeys' => [],
            ];

            $sql = Sql::instance()->prepare("
                SELECT *
                FROM INFORMATION_SCHEMA.COLUMNS
                WHERE table_name = ?
                ORDER BY ordinal_position ASC
            ");
            $sql->execute([
                $table,
            ]);

            foreach ($sql->fetchAll() as $field) {
                $info['fields'][$field['columnName']] = new Field([
                    'name'                => $field['column_name'],
                    'type'                => strtolower($field['udt_name']),
                    'size'                => (int) $field['character_maximum_length'] ?: (int) $field['numeric_precision'],
                    'decimals'            => (int) $field['numeric_scale'] ?: null,
                    'unsigned'            => false,
                    'autoincrement'       => stripos($field['column_default'], 'nextval') !== false,
                    'autoGeneratedInsert' => $field['column_default'] !== null,
                    'allowNull'           => strtolower($field['is_nullable']) === 'yes',
                    'casting'             => self::fieldCasting(strtolower($field['udt_name']), (int) $field['character_maximum_length'] ?: (int) $field['numeric_precision']),
                    'castingExtended'     => self::fieldCastingExtended(strtolower($field['udt_name']), (int) $field['character_maximum_length'] ?: (int) $field['numeric_precision']),
                    'binary'              => self::fieldIsBinary(strtolower($field['udt_name'])),
                    'boolTrue'            => self::booleanTrueValue(strtolower($field['udt_name'])),
                ]);

                $info['primaryKeys'] = self::primaryKeys($table);
                $info['uniqueKeys']  = self::uniqueKeys($table);
                $info['indexes']      = self::indexes($table);
                $info['foreignKeys'] = self::foreignKeys($table);

                // filter out primary keys from unique keys - duplicate/overlapping indexes can cause problems
                foreach ($info['uniqueKeys'] as $k => $fields) {
                    if (count($info['primaryKeys']) === count($fields)) {
                        $duplicate = true;
                        $f1 = array_values($info['primaryKeys']);
                        $f2 = array_values($fields);
                        sort($f1);
                        sort($f2);
                        foreach ($f1 as $i => $f) {
                            if ($f !== $f2[$i]) {
                                $duplicate = false;
                            }
                        }

                        if ($duplicate) {
                            unset($info['uniqueKeys'][$k]);
                        }
                    }
                }

                // filter out primary keys from indexes - duplicate/overlapping indexes can cause problems
                foreach ($info['indexes'] as $k => $fields) {
                    if (count($info['primaryKeys']) === count($fields)) {
                        $duplicate = true;
                        $f1 = array_values($info['primaryKeys']);
                        $f2 = array_values($fields);
                        sort($f1);
                        sort($f2);
                        foreach ($f1 as $i => $f) {
                            if ($f !== $f2[$i]) {
                                $duplicate = false;
                            }
                        }

                        if ($duplicate) {
                            unset($info['indexes'][$k]);
                        }
                    }
                }
            }

            return $info;
        }

        public static function primaryKeys($table) {
            $sql = Sql::instance()->prepare("
                SELECT
                    pg_attribute.attname
                FROM
                    pg_index,
                    pg_class,
                    pg_attribute
                WHERE
                    pg_class.oid = '{$table}'::regclass
                    AND indrelid = pg_class.oid
                    AND pg_attribute.attrelid = pg_class.oid
                    AND pg_attribute.attnum = any(pg_index.indkey)
                    AND indisprimary
            ");
            $sql->execute();
            $pk = [];
            foreach ($sql->fetchAll() as $field) {
                $pk[] = $field['attname'];
            }
            return $pk;
        }

        public static function uniqueKeys($table) {
            $sql = Sql::instance()->prepare("
                SELECT
                    tc.constraint_name,
                    kcu.column_name
                FROM
                    information_schema.table_constraints tc
                JOIN information_schema.key_column_usage kcu
                ON tc.constraint_name = kcu.constraint_name
                JOIN information_schema.constraint_column_usage ccu
                ON ccu.constraint_name = tc.constraint_name
                WHERE
                    constraint_type = 'UNIQUE'
                    AND tc.table_name='{$table}'
                ORDER BY ordinal_position ASC
            ");
            $sql->execute();
            $keys = [];
            foreach ($sql->fetchAll() as $field) {
                if (! isset($keys[$field['constraint_name']]) || ! in_array($field['column_name'], $keys[$field['constraint_name']])) {
                    $keys[$field['constraint_name']][] = $field['column_name'];
                }
            }
            return $keys;
        }

        public static function indexes($table) {
            $sql = Sql::instance()->prepare("
                SELECT
                    t.relname table_name,
                    i.relname index_name,
                    a.attname column_name
                FROM
                    pg_class t,
                    pg_class i,
                    pg_index ix,
                    pg_attribute a
                WHERE
                    t.oid = ix.indrelid
                    AND i.oid = ix.indexrelid
                    AND a.attrelid = t.oid
                    AND a.attnum = ANY(ix.indkey)
                    AND t.relkind = 'r'
                    AND t.relname LIKE '{$table}'
            ");
            $sql->execute();
            $indexes = [];
            foreach ($sql->fetchAll() as $field) {
                if (! isset($indexes[$field['index_name']]) || ! in_array($field['column_name'], $indexes[$field['index_name']])) {
                    $indexes[$field['index_name']][] = $field['column_name'];
                }
            }
            return $indexes;
        }

        public static function foreignKeys($table) {
            $sql = Sql::instance()->prepare("
                SELECT
                    tc.constraint_name,
                    tc.table_name,
                    kcu.column_name,
                    ccu.table_name foreign_table_name,
                    ccu.column_name foreign_column_name
                FROM
                    information_schema.table_constraints tc
                JOIN information_schema.key_column_usage kcu
                ON tc.constraint_name = kcu.constraint_name
                JOIN information_schema.constraint_column_usage ccu
                ON ccu.constraint_name = tc.constraint_name
                WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name='{$table}'
            ");
            $sql->execute();
            $fks = [];
            foreach ($sql->fetchAll() as $field) {
                if (! isset($fks[$field['constraint_name']]) || ! in_array($field['constraint_name'], $fks[$field['constraint_name']])) {
                    $fks[$field['constraint_name']] = [
                        'name'        => $field['constraint_name'],
                        'field'       => $field['column_name'],
                        'parentTable' => $field['foreign_table_name'],
                        'parentField' => $field['foreign_column_name'],
                    ];
                }
            }
            return $fks;
        }

        public static function fieldCasting($type, $length) {
            switch (trim(strtolower($type))) {
                case 'bigint':
                case 'serial':
                case 'bigserial':
                case 'smallint':
                case 'double precision':
                case 'integer':
                case 'interval':
                case 'int2':
                case 'int4':
                case 'int8':
                    return 'int';

                case 'float4':
                case 'float8':
                    return 'float';

                case 'boolean':
                    return 'bool';

                case 'bytea':
                    return 'binary';

                default:
                    return 'string';
            }
        }

        public static function fieldCastingExtended($type, $length) {
            switch (trim(strtolower($type))) {
                case 'bigint':
                case 'serial':
                case 'bigserial':
                case 'smallint':
                case 'double precision':
                case 'integer':
                case 'interval':
                case 'int2':
                case 'int4':
                case 'int8':
                    return 'int';

                case 'float4':
                case 'float8':
                    return 'float';

                case 'boolean':
                    return 'bool';

                case 'bytea':
                    return 'binary';

                case 'money':
                case 'decimal':
                case 'real':
                case 'numeric':

                case 'bit':
                case 'bit varying':

                case 'tsquery':

                case 'date':
                case 'xml':
                case 'time':
                case 'timez':
                case 'timestamp':
                case 'timestampz':
                case 'text':
                case 'macaddr':
                case 'cidr':
                case 'inet':
                case 'character varying':
                case 'character':
                case 'uuid':

                case 'circle':
                case 'box':
                case 'line':
                case 'lseg':
                case 'path':
                case 'point':
                case 'polygon':
                case 'tsvector':
                case 'txid_snapshot':

                    return 'string';

                default:
                    return 'string';
            }
        }

        public static function fieldIsBinary($type) {
            return in_array(
                trim(strtolower($type)),
                [
                    'bytea',
                ]
            );
        }

        public function booleanTrueValue($details) {
            if (array_key_exists(strtolower($details), self::$enum_values)) {
                return self::$enum_values[strtolower($details)];
            }
        }

        /**
         * Identify driver specific validation for this field
         *
         * @param Field $field
         *
         * @return string
         */
        public static function apiTypeValidation(Field $field) {
            //max sizes
            switch ((string) $field->getType()) {
                case 'bit':
                    return "->requireDigit(0, 1)";

                case 'smallint':
                case 'int2':
                    return "->requireDigit(-32768, 32767)";

                case 'integer':
                case 'int4':
                case 'serial':
                    return "->requireDigit(-2147483648, 2147483647)";

                case 'bigint':
                case 'int8':
                case 'bigserial':
                    return "->requireDigit(-9223372036854775808, 9223372036854775807)";

                case 'varchar':
                case 'char':
                    return "->requireLength(1, {$field->getSize()})";

                case 'timestamp':
                case 'timestampz':
                case 'datetime':
                    return "->isDateTime()";

                case 'date':
                    return "->isDate()";

                case 'enum':
                    return "->isIn([{$field->getVarInfo()}])";
            }
        }

        public static function isTableTiny(table $table) {
            // technically there's no such thing as a tiny table in PGSQL since the smallest int size is 16bit...
            return false;
        }

        /**
         * @param Field $field
         *
         * @return bool
         */
        public static function isFieldLookupable(Field $field) {
            switch ((string) $field->getType()) {
                case 'timestamp':
                case 'timestampz':
                case 'datetime':
                    return false;

                default:
                    return true;
            }
        }
    }